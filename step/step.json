[
    "特征人脸算法：完成函数 eigen_train：\ndef eigen_train(trainset, k=20):\n\t\"\"\"\n\t训练特征脸（eigenface）算法的实现\n\n\t:param trainset: 使用 get_images 函数得到的处理好的人脸数据训练集\n\t:param K: 希望提取的主特征数\n\t:return: 训练数据的平均脸, 特征脸向量, 中心化训练数据\n\t\"\"\"\n\n\t# 返回：平均人脸、特征人脸、中心化人脸\n\treturn avg_img, feature, norm_img\n其中输入的 trainset.shape 的格式为 (num, area)，num 表示数据集中的人脸图像数，area 表示数据集中人脸图像的统一大小（像素）；\n输出的 avg_img.shape, feature.shape, norm_img.shape 的格式为 (area, )，表示结果人脸图像的大小，并且需要保持与 trainset 中的图像大小一致。\n参考答案：\ndef eigen_train(trainset, k=20):\n\t# Step 1: 计算平均人脸\n\tavg_img = np.mean(trainset, axis=0)  # 按列求均值，得到平均脸\n\n\t# Step 2: 中心化人脸图像（去掉均值）\n\tnorm_img = trainset - avg_img  # 每张图像减去平均脸\n\n\t# Step 3: 计算协方差矩阵\n\t# 计算 norm_img 的协方差矩阵，使用小规模的矩阵（norm_img * norm_img.T）\n\teigvals_u, eig_u = np.linalg.eig(np.dot(norm_img, norm_img.T))\n\n\t# Step 4: 排序特征值和特征向量\n\tsorted_idx = np.argsort(eigvals_u)[::-1]  # 降序排列索引\n\teigvals_u = eigvals_u[sorted_idx]  # 根据索引排序特征值\n\teig_u = eig_u[:, sorted_idx]  # 根据索引排序特征向量\n\n\t# Step 5: 计算高维特征脸\n\tfeature = np.dot(norm_img.T, eig_u)  # 从特征向量空间转换到高维空间\n\n\t# Step 6: 特征脸归一化\n\tfeature = feature / np.linalg.norm(feature, axis=0)  # 每列归一化\n\tfeature = feature.T[:k, ]  # 选择前 k 个特征脸\n\n\t# 返回：平均人脸、特征人脸、中心化人脸\n\treturn avg_img, feature, norm_img",
    "人脸识别实验：完成函数 rep_face：\ndef rep_face(image, avg_img, eigenface_vects, numComponents=0):\n\t\"\"\"\n\t用特征脸（eigenface）算法对输入数据进行投影映射，得到使用特征脸向量表示的数据\n\n\t:param image: 输入数据\n\t:param avg_img: 训练集的平均人脸数据\n\t:param eigenface_vects: 特征脸向量\n\t:param numComponents: 选用的特征脸数量\n\t:return: 输入数据的特征向量表示, 最终使用的特征脸数量\n\t\"\"\"\n\t\n\t# 返回：输入数据的特征向量表示, 特征脸使用数量\n\treturn representation, numComponents\n其中输入的 image.shape, avg_img.shape 的格式为 (area, )，表示结果人脸图像的大小；\neigenface_vects.shape 的格式为 (num, area)，num 表示数据集中的人脸图像数，area 表示数据集中人脸图像的统一大小（像素）；\n输出的 representation.shape 的格式为 (num, )，num 表示数据集中的人脸图像数。\n参考答案：\ndef rep_face(image, avg_img, eigenface_vects, numComponents=0):\n\n\t# Step 1: 计算输入图像与平均人脸之间的差异\n\t# 将输入图像减去平均人脸，得到中心化的图像\n\tnorm_img = image - avg_img\n\n\t# Step 2: 投影到特征空间\n\t# 使用特征脸向量对中心化的图像进行投影，得到特征向量表示\n\trepresentation = np.dot(norm_img, eigenface_vects[:numComponents, ].T)\n\n\t# Step 3: 确定使用的特征脸数量\n\tnumEigenFaces = numComponents  # 记录实际使用的特征脸数量\n\n\t# 返回：输入数据的特征向量表示, 特征脸使用数量\n\treturn representation, numEigenFaces",
    "人脸重构实验：完成函数 recFace:\ndef recFace(representations, avg_img, eigenface_vects, numComponents, sz=(112, 92)):\n\t\"\"\"\n\t利用特征人脸重建原始人脸\n\n\t:param representations: 表征数据\n\t:param avg_img: 训练集的平均人脸数据\n\t:param eigenface_vects: 特征脸向量\n\t:param numComponents: 选用的特征脸数量\n\t:param sz: 原始图片大小\n\t:return: 重建人脸, str 使用的特征人脸数量\n\t\"\"\"\n\n\t# 返回: 重建人脸, str 使用的特征人脸数量\n\treturn face_reconstruction, 'numEigenFaces_{}'.format(numComponents)\n其中输入的 representations.shape 为 (num, )，num 表示用于进行人脸重构的特征脸数量；\navg_img.shape 格式为 (area, )， area 表示人脸图像的统一大小（像素）；\neigenface_vects.shape 格式为 (num, area)，num 表示人脸图像的个数，area 表示人脸图像的统一大小（像素）；\n输出的 face_reconstruction.shape 格式为 (area, )，area 表示人脸图像的统一大小（像素）。\n参考答案：\ndef recFace(representations, avg_img, eigenface_vects, numComponents, sz=(112, 92)):\n\n\t# Step 1: 选取前 numComponents 个特征脸\n\tselected_eigenfaces = eigenface_vects[:numComponents]  # 取出选定的特征脸向量\n\n\t# Step 2: 重建图像\n\tface_reconstruction = avg_img + np.dot(representations[:numComponents], selected_eigenfaces)  # 计算重建的图像\n\n\t# Step 3: 确保重建图像的形状正确\n\tface_reconstruction = face_reconstruction.reshape(sz)  # 将重建图像调整为原始大小\n\n\t# 返回: 重建人脸, str 使用的特征人脸数量\n\treturn face_reconstruction, 'numEigenFaces_{}'.format(numComponents)"
]